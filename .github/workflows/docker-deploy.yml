name: CI/CD IAM Role Based Docker Deploy

on:
  push:
    branches: [ "main", "release", "docker" ]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Source Code
        uses: actions/checkout@v4

      # ---------------------------------------------------
      # 1. Docker Build & Push (Î™®Îì† Î∏åÎûúÏπò Í≥µÌÜµ Ïã§Ìñâ)
      # ---------------------------------------------------
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Docker Meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.DOCKER_USERNAME }}/caring-back
          tags: |
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/release' }}
            type=raw,value=docker,enable=${{ github.ref == 'refs/heads/docker' }}
            type=raw,value=dev,enable=${{ github.ref == 'refs/heads/main' }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          # Î†àÏù¥Ïñ¥ Ï∫êÏãúÎ•º Ï†ÅÍ∑π ÌôúÏö©ÌïòÎèÑÎ°ù ÏÑ§Ï†ï Ïú†ÏßÄ
          cache-from: type=registry,ref=${{ secrets.DOCKER_USERNAME }}/caring-back:buildcache
          cache-to: type=registry,ref=${{ secrets.DOCKER_USERNAME }}/caring-back:buildcache,mode=max

      # ---------------------------------------------------
      # Deploy Steps (release ÌòπÏùÄ docker Î∏åÎûúÏπòÏùº Îïå Ïã§Ìñâ)
      # ---------------------------------------------------
      - name: Checkout Config Repository (ÏõêÎ≥∏ ÌååÏùº Í∞ÄÏ†∏Ïò§Í∏∞)
        if: github.ref == 'refs/heads/release' || github.ref == 'refs/heads/docker'
        uses: actions/checkout@v4
        with:
          repository: safori-team/Caring-Back-Env
          token: ${{ secrets.GH_PAT }}
          path: config-repo

      - name: Bundle & Encrypt Config Files
        if: github.ref == 'refs/heads/release' || github.ref == 'refs/heads/docker'
        id: config
        env:
          ENCRYPT_KEY: ${{ secrets.DECRYPT_KEY }}
        run: |
          echo "üì¶ Compressing raw config files..."
          tar -czf configs.tar.gz --exclude=.git -C config-repo .
          
          echo "üîí Encrypting config package..."
          # OpenSSLÎ°ú ÏïîÌò∏Ìôî (configs.tar.gz -> configs.enc)
          # Ïó¨Í∏∞ÏÑú Ïì∞Îäî ÌÇ§($ENCRYPT_KEY)ÏôÄ AWS Parameter StoreÏóê Ï†ÄÏû•Îêú ÌÇ§Í∞Ä Í∞ôÏïÑÏïº Ìï©ÎãàÎã§.
          openssl enc -aes-256-cbc -salt -in configs.tar.gz -out configs.enc -k "$ENCRYPT_KEY"
          
          echo "üì§ Encoding for transfer..."
          CONFIG_DATA=$(base64 -w 0 configs.enc)
          echo "CONFIG_DATA=$CONFIG_DATA" >> $GITHUB_OUTPUT

      - name: Configure AWS credentials
        if: github.ref == 'refs/heads/release' || github.ref == 'refs/heads/docker'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Deploy via AWS SSM
        if: github.ref == 'refs/heads/release' || github.ref == 'refs/heads/docker'
        env:
          TARGET_TAG: ${{ github.ref == 'refs/heads/release' && 'latest' || 'docker' }}
        run: |
          echo "üîé Finding instances with tag DeployGroup=Caring-Server..."
          INSTANCE_IDS=$(aws ec2 describe-instances \
            --filters "Name=tag:DeployGroup,Values=Caring-Server" "Name=instance-state-name,Values=running" \
            --query "Reservations[].Instances[].InstanceId" \
            --output text)
          
          if [ -z "$INSTANCE_IDS" ] || [ "$INSTANCE_IDS" == "None" ]; then
            echo "‚ùå Error: Ïã§Ìñâ Ï§ëÏù∏ ÏÑúÎ≤ÑÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. EC2 ÌÉúÍ∑∏(DeployGroup=Caring-Server)Î•º ÌôïÏù∏ÌïòÏÑ∏Ïöî."
            exit 1
          fi
          
          INSTANCE_IDS=$(echo $INSTANCE_IDS | tr '\n' ' ')
          echo "üöÄ Target Instances: $INSTANCE_IDS"

          COMMAND_ID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "Key=tag:DeployGroup,Values=Caring-Server" \
            --max-concurrency "100%" \
            --max-errors "0" \
            --output text \
            --query "Command.CommandId" \
            --parameters 'commands=[
              "echo [Deploy] Starting Deployment for tag: ${{ env.TARGET_TAG }}...",
              "echo [Deploy] Target Info: $(hostname)",
          
              "mkdir -p /home/ubuntu/caring-voice/credentials",
              "mkdir -p /home/ubuntu/.cache/huggingface",
              "chmod 777 /home/ubuntu/.cache/huggingface",
              "rm -rf /home/ubuntu/caring-voice/credentials/*",

              "echo ${{ steps.config.outputs.CONFIG_DATA }} | base64 -d > /tmp/configs.enc",
          
              "echo [Deploy] Fetching decryption key from AWS Parameter Store...",
              "DECRYPT_KEY=$(aws ssm get-parameter --name /caring-voice/deploy-key --with-decryption --query Parameter.Value --output text --region ap-northeast-2)",
          
              "openssl enc -d -aes-256-cbc -in /tmp/configs.enc -out /tmp/configs.tar.gz -k $DECRYPT_KEY",
          
              "unset DECRYPT_KEY",

              "tar -xzf /tmp/configs.tar.gz -C /home/ubuntu/caring-voice/credentials",
          
              "rm /tmp/configs.enc /tmp/configs.tar.gz",
              "chmod -R 600 /home/ubuntu/caring-voice/credentials/*",
          
              "echo ${{ secrets.DOCKER_PASSWORD }} | docker login -u ${{ secrets.DOCKER_USERNAME }} --password-stdin",
          
              "echo [Deploy] Pulling image...",
              "docker pull ${{ secrets.DOCKER_USERNAME }}/caring-back:${{ env.TARGET_TAG }}",
          
              "docker stop caring-server || true",
              "docker rm caring-server || true",
          
              "echo [Deploy] Running container...",
              "docker run -d --name caring-server --restart always -p 8000:8000 --env-file /home/ubuntu/caring-voice/credentials/docker.env -v /home/ubuntu/caring-voice/credentials:/caring-voice/credentials -v /home/ubuntu/.cache/huggingface:/data/model_cache ${{ secrets.DOCKER_USERNAME }}/caring-back:${{ env.TARGET_TAG }}",
          
              "docker image prune -f",
              "echo [Deploy] SUCCESS on $(hostname)!"
            ]' \
            --comment "Deploying ${{ env.TARGET_TAG }}")

          echo "üì° Command sent! ID: $COMMAND_ID"
          echo "‚è≥ Waiting for command execution on all targets..."
          
          EXIT_CODE=0
          for ID in $INSTANCE_IDS; do
            echo "Checking instance: $ID"
          
            aws ssm wait command-executed --command-id "$COMMAND_ID" --instance-id "$ID"
          
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$ID" \
              --query "Status" \
              --output text)
          
            if [ "$STATUS" != "Success" ]; then
              echo "‚ùå Failed on instance $ID (Status: $STATUS)"
              echo "--- Error Logs ($ID) ---"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$ID" \
                --query "StandardErrorContent" \
                --output text
              EXIT_CODE=1
            else
              echo "‚úÖ Success on instance $ID"
            fi
          done

          if [ $EXIT_CODE -ne 0 ]; then
            echo "‚ùå Deployment finished with errors."
            exit 1
          else
            echo "üéâ All deployments succeeded!"
          fi
